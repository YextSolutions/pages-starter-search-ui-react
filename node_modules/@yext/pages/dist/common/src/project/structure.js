import pathLib from "node:path";
import merge from "lodash/merge.js";
import { Path } from "./path.js";
import { determineAssetsFilepath } from "../assets/getAssetsFilepath.js";
import { determinePublicFilepath } from "../assets/getPublicFilepath.js";
const DEFAULT_ASSETS_DIR = "assets";
const DEFAULT_PUBLIC_DIR = "public";
const defaultProjectStructureConfig = {
  rootFolders: {
    source: "src",
    dist: "dist",
    sitesConfig: "sites-config",
    functions: "functions"
  },
  subfolders: {
    templates: "templates",
    serverlessFunctions: "functions",
    assets: DEFAULT_ASSETS_DIR,
    public: DEFAULT_PUBLIC_DIR,
    clientBundle: "client",
    serverBundle: "server",
    renderBundle: "render",
    renderer: "renderer",
    static: "static",
    plugin: "plugin"
  },
  sitesConfigFiles: {
    ci: "ci.json",
    features: "features.json",
    siteStream: "site-stream.json",
    serving: "serving.json",
    sitemap: "sitemap.json",
    redirects: "redirects.csv",
    auth: "auth.json"
  },
  distConfigFiles: {
    templates: "templates.json",
    artifacts: "artifacts.json",
    functionMetadata: "functionMetadata.json"
  },
  rootFiles: {
    config: "config.yaml"
  },
  envVarConfig: {
    envVarDir: "",
    envVarPrefix: "YEXT_PUBLIC"
  }
};
class ProjectStructure {
  config;
  constructor(config) {
    const mergedConfig = merge(defaultProjectStructureConfig, config);
    this.config = mergedConfig;
  }
  static init = async (projectStructureConfig) => {
    const config = merge(defaultProjectStructureConfig, projectStructureConfig);
    const assetsDir = await determineAssetsFilepath(
      DEFAULT_ASSETS_DIR,
      pathLib.resolve("vite.config.js")
    );
    config.subfolders.assets = assetsDir;
    const publicDir = await determinePublicFilepath(
      DEFAULT_PUBLIC_DIR,
      pathLib.resolve("vite.config.js")
    );
    config.subfolders.public = publicDir;
    return new ProjectStructure(config);
  };
  /**
   * @returns the list of of src/templates, taking scope into account. If a scope is defined then
   * both the scoped and non-scoped template paths are returned.
   */
  getTemplatePaths = () => {
    const templatesRoot = pathLib.join(
      this.config.rootFolders.source,
      this.config.subfolders.templates
    );
    if (this.config.scope) {
      return [
        new Path(pathLib.join(templatesRoot, this.config.scope)),
        new Path(templatesRoot)
      ];
    }
    return [new Path(templatesRoot)];
  };
  /**
   * @returns the {@link Path} to the sites-config folder, taking scope into account.
   */
  getSitesConfigPath = () => {
    return new Path(
      pathLib.join(this.config.rootFolders.sitesConfig, this.config.scope ?? "")
    );
  };
  /**
   * @returns the {@link Path} to the dist folder, taking scope into account.
   */
  getScopedDistPath = () => {
    return new Path(
      pathLib.join(this.config.rootFolders.dist, this.config.scope ?? "")
    );
  };
}
export {
  ProjectStructure
};
