import {
  Project,
  SyntaxKind
} from "ts-morph";
import typescript from "typescript";
function createTsMorphProject() {
  return new Project({
    compilerOptions: {
      jsx: typescript.JsxEmit.ReactJSX
    }
  });
}
class SourceFileParser {
  constructor(filepath, project) {
    this.filepath = filepath;
    if (!project.getSourceFile(filepath)) {
      project.addSourceFileAtPath(filepath);
    }
    this.sourceFile = project.getSourceFileOrThrow(filepath);
  }
  sourceFile;
  getFunctions() {
    return this.sourceFile.getFunctions();
  }
  /**
   * getChildExpressions looks for expressions called within a parent expression.
   * @param parentExpressionName the expression to parse through
   * @param allChildExpressions an array to save parsed expression names into
   */
  getChildExpressions(parentExpressionName, allChildExpressions) {
    const parentExpression = this.sourceFile.getVariableStatement(parentExpressionName);
    const descendantIdentifiers = parentExpression?.getDescendantsOfKind(
      SyntaxKind.Identifier
    );
    descendantIdentifiers?.forEach((identifier) => {
      if (!allChildExpressions.includes(identifier.getText().trim())) {
        allChildExpressions.push(identifier.getText().trim());
        this.getChildExpressions(
          identifier.getText().trim(),
          allChildExpressions
        );
      }
    });
  }
  /**
   * @param names the names of the expressions
   * @returns string[] containing code of each expression
   */
  getExpressionsByName(names) {
    const expressions = [];
    names.forEach((name) => {
      expressions.push(this.getExpressionByName(name));
    });
    return expressions;
  }
  /**
   * Ex. source file contains const foo = 5;
   * getExpressionByName("foo") returns "const foo = 5;"
   * @param name of expression
   * @returns string containing expression's code
   */
  getExpressionByName(name) {
    if (this.sourceFile.getImportDeclaration(name)) {
      return "";
    }
    let expression = this.sourceFile.getVariableStatement(name)?.getText();
    expression ??= this.sourceFile.getFunction(name)?.getText();
    expression ??= this.sourceFile.getInterface(name)?.getText();
    expression ??= this.sourceFile.getTypeAlias(name)?.getText();
    return expression ?? "";
  }
  /**
   * Adds any strings into source file.
   * @param expressions the strings to add
   */
  addExpressions(expressions) {
    this.sourceFile.addStatements(expressions);
  }
  /**
   * getDefaultExport parses the source file for a default export.
   * @returns the default export's name
   */
  getDefaultExport() {
    const defaultExportSymbol = this.sourceFile.getDefaultExportSymbol();
    if (!defaultExportSymbol) {
      return "";
    }
    const declarations = defaultExportSymbol.getDeclarations();
    const exportDeclaration = declarations[0];
    if (exportDeclaration.isKind(SyntaxKind.FunctionDeclaration)) {
      return exportDeclaration.getName() ?? "";
    } else if (exportDeclaration.isKind(SyntaxKind.ExportAssignment)) {
      const expression = this.sourceFile.getExportAssignment(
        (d) => !d.isExportEquals()
      );
      const defaultName = expression?.getChildAtIndex(2).getText();
      return defaultName ?? "";
    }
    return "";
  }
  /**
   * Adds the default export to source file.
   * @param defaultName the default export's name
   */
  addDefaultExport(defaultName) {
    this.sourceFile.addExportAssignment({
      expression: defaultName,
      isExportEquals: false
      // set to default
    });
  }
  /**
   * @returns all imports from source file
   */
  getAllImports() {
    const allImports = [];
    const imports = this.sourceFile.getImportDeclarations();
    imports.forEach((importDec) => {
      const moduleSpecifier = importDec.getModuleSpecifierValue();
      const namedImportsAsString = [];
      importDec.getNamedImports()?.forEach((namedImport) => {
        namedImportsAsString.push(namedImport.getName());
      });
      const attributes = [];
      importDec.getAttributes()?.getElements()?.forEach((element) => {
        attributes.push({
          value: element.getValue().getText(),
          name: element.getName()
        });
      });
      allImports.push({
        isTypeOnly: importDec.isTypeOnly(),
        defaultImport: importDec.getDefaultImport()?.getText(),
        namedImports: namedImportsAsString,
        namespaceImport: importDec.getNamespaceImport()?.getText(),
        moduleSpecifier,
        attributes: attributes.length === 0 ? void 0 : attributes
      });
    });
    return allImports;
  }
  /**
   * Adds the imports into source file.
   * @param allImports
   */
  setAllImports(allImports) {
    allImports.forEach((importDec) => {
      let moduleSpecifier;
      this.sourceFile.addImportDeclaration({
        isTypeOnly: importDec.isTypeOnly,
        defaultImport: importDec.defaultImport,
        namedImports: importDec.namedImports,
        namespaceImport: importDec.namespaceImport,
        moduleSpecifier: moduleSpecifier ?? importDec.moduleSpecifier,
        attributes: importDec.attributes
      });
    });
    this.sourceFile.fixMissingImports().organizeImports().fixUnusedIdentifiers();
  }
  getFileName() {
    return this.sourceFile.getBaseName();
  }
  /**
   * Saves all changes made to source file.
   */
  save() {
    this.sourceFile.saveSync();
  }
  getAllText() {
    return this.sourceFile.getFullText();
  }
}
export {
  createTsMorphProject,
  SourceFileParser as default
};
