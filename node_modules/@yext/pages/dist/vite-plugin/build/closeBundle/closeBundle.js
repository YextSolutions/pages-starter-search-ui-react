import { glob } from "glob";
import * as path from "path";
import { pathToFileURL } from "url";
import fs from "fs";
import logger from "../../log.js";
import { generateManifestFile } from "./manifest.js";
import { validateBundles } from "./bundleValidator.js";
import {
  generateFunctionMetadataFile,
  shouldGenerateFunctionMetadata
} from "./functionMetadata.js";
import { updateCiConfig } from "../../../generate/ci/ci.js";
import { getFunctionFilepaths } from "../../../common/src/function/internal/getFunctionFilepaths.js";
import {
  bundleServerlessFunctions,
  shouldBundleServerlessFunctions
} from "./serverlessFunctions.js";
import { createTemplatesJsonFromModule } from "../../../generate/templates/createTemplatesJson.js";
import { convertToPosixPath } from "../../../common/src/template/paths.js";
import {
  loadTemplateModules
} from "../../../common/src/template/loader/loader.js";
import { logErrorAndClean } from "../../../util/logError.js";
import { isUsingConfig } from "../../../util/config.js";
import { createArtifactsJson } from "../../../generate/artifacts/createArtifactsJson.js";
import { Path } from "../../../common/src/project/path.js";
import { getLocalDataForEntityOrStaticPage } from "../../../dev/server/ssr/getLocalData.js";
var closeBundle_default = (projectStructure) => {
  return async () => {
    let finisher = logger.timedLog({ startLog: "Validating template modules" });
    let templateModules;
    const { rootFolders, subfolders } = projectStructure.config;
    try {
      const serverBundles = glob.sync(
        convertToPosixPath(
          path.join(
            path.resolve(
              rootFolders.dist,
              subfolders.assets,
              subfolders.serverBundle
            ),
            "**/*.js"
          )
        ),
        {
          ignore: path.join(
            path.resolve(rootFolders.dist, subfolders.serverlessFunctions),
            "**"
          )
        }
      );
      templateModules = await loadTemplateModules(
        serverBundles,
        false,
        true,
        projectStructure
      );
      validateUniqueFeatureName(templateModules);
      await validateUniqueStaticPaths(templateModules);
      validateBundles(projectStructure);
      finisher.succeed("Validated template modules");
    } catch (e) {
      finisher.fail("One or more template modules failed validation");
      await logErrorAndClean(e, projectStructure);
      return;
    }
    if (shouldGenerateFunctionMetadata(projectStructure)) {
      finisher = logger.timedLog({ startLog: "Validating functions" });
      try {
        const functionFilepaths = getFunctionFilepaths(
          path.join(
            projectStructure.config.rootFolders.dist,
            projectStructure.config.subfolders.serverlessFunctions
          )
        );
        await Promise.all(
          functionFilepaths.map(async (filepath) => {
            const jsFilepath = path.format(filepath).replace(".ts", ".js");
            try {
              fs.copyFileSync(path.format(filepath), jsFilepath);
              const functionModule = await import(pathToFileURL(
                path.format(filepath).replace(".ts", ".js")
              ).toString());
              if (!functionModule.default) {
                return Promise.reject(
                  `${path.format(filepath)} is missing a default export.`
                );
              }
            } finally {
              fs.unlinkSync(jsFilepath);
            }
          })
        );
        finisher.succeed("Validated functions");
      } catch (e) {
        finisher.fail("One or more functions failed validation");
        await logErrorAndClean(e, projectStructure);
      }
      finisher = logger.timedLog({ startLog: "Writing functionMetadata.json" });
      try {
        await generateFunctionMetadataFile(projectStructure);
        finisher.succeed("Successfully wrote functionMetadata.json");
      } catch (e) {
        finisher.fail("Failed to write functionMetadata.json");
        await logErrorAndClean(e, projectStructure);
      }
    }
    if (shouldBundleServerlessFunctions(projectStructure)) {
      finisher = logger.timedLog({ startLog: "Bundling serverless functions" });
      try {
        await bundleServerlessFunctions(projectStructure);
        finisher.succeed("Successfully bundled serverless functions");
      } catch (e) {
        finisher.fail("Failed to bundle serverless functions");
        await logErrorAndClean(e, projectStructure);
      }
    }
    const configYamlName = projectStructure.config.rootFiles.config;
    if (isUsingConfig(configYamlName, projectStructure.config.scope)) {
      finisher = logger.timedLog({ startLog: "Writing templates.json" });
      try {
        createTemplatesJsonFromModule(
          templateModules,
          projectStructure,
          "TEMPLATES"
        );
        finisher.succeed("Successfully wrote templates.json");
      } catch (e) {
        finisher.fail("Failed to write templates.json");
        await logErrorAndClean(e, projectStructure);
      }
    } else {
      finisher = logger.timedLog({ startLog: "Writing features.json" });
      try {
        createTemplatesJsonFromModule(
          templateModules,
          projectStructure,
          "FEATURES"
        );
        finisher.succeed("Successfully wrote features.json");
      } catch (e) {
        finisher.fail("Failed to write features.json");
        await logErrorAndClean(e, projectStructure);
      }
    }
    finisher = logger.timedLog({ startLog: "Writing manifest.json" });
    try {
      await generateManifestFile(templateModules, projectStructure);
      finisher.succeed("Successfully wrote manifest.json");
    } catch (e) {
      finisher.fail("Failed to write manifest.json");
      await logErrorAndClean(e, projectStructure);
    }
    if (isUsingConfig(configYamlName, projectStructure.config.scope)) {
      finisher = logger.timedLog({ startLog: "Writing artifacts.json" });
      try {
        const artifactPath = new Path(
          path.join(
            projectStructure.getScopedDistPath().path,
            projectStructure.config.distConfigFiles.artifacts
          )
        );
        await createArtifactsJson(
          artifactPath.getAbsolutePath(),
          projectStructure
        );
        finisher.succeed("Successfully wrote artifacts.json");
      } catch (e) {
        finisher.fail("Failed to update artifacts.json");
        await logErrorAndClean(e, projectStructure);
      }
    } else {
      finisher = logger.timedLog({ startLog: "Updating ci.json" });
      try {
        const sitesConfigAbsolutePath = projectStructure.getSitesConfigPath().getAbsolutePath();
        await updateCiConfig(
          path.join(
            sitesConfigAbsolutePath,
            projectStructure.config.sitesConfigFiles.ci
          ),
          false,
          projectStructure
        );
        finisher.succeed("Successfully updated ci.json");
      } catch (e) {
        finisher.fail("Failed to update ci.json");
        await logErrorAndClean(e, projectStructure);
      }
    }
  };
};
const validateUniqueFeatureName = (templateModuleCollection) => {
  const featureNames = /* @__PURE__ */ new Set();
  [...templateModuleCollection.keys()].forEach((featureName) => {
    if (featureNames.has(featureName)) {
      throw `Templates must have unique feature names. Found multiple modules with "${featureName}"`;
    }
    featureNames.add(featureName);
  });
};
const validateUniqueStaticPaths = (templateModuleCollection) => {
  const paths = /* @__PURE__ */ new Set();
  const pathPromises = [...templateModuleCollection.values()].map(
    async (module) => {
      if (!module.config.locales) {
        return;
      }
      for (const locale of module.config.locales) {
        const document = await getLocalDataForEntityOrStaticPage({
          entityId: "",
          locale,
          featureName: module.config.name
        });
        const path2 = module.getPath({ document });
        if (paths.has(path2)) {
          throw `Path "${path2}" is used by multiple static pages.  Check that the getPath() function in the template "${module.templateName}" returns a unique path for each locale.`;
        } else {
          paths.add(path2);
        }
      }
    }
  );
  return Promise.all(pathPromises);
};
export {
  closeBundle_default as default
};
