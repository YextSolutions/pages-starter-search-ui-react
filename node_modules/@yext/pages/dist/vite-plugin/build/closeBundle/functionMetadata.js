import fs from "fs";
import path from "path";
import { Project, Node, SyntaxKind } from "ts-morph";
import { glob } from "glob";
import { convertToPosixPath } from "../../../common/src/template/paths.js";
const project = new Project();
const getFunctionMetadataMap = async (projectStructure) => {
  const filepaths = glob.sync(
    convertToPosixPath(
      path.join(projectStructure.config.rootFolders.functions, "**/*.{js,ts}")
    ),
    { nodir: true }
  ).map((f) => path.resolve(f));
  project.addSourceFilesAtPaths(filepaths);
  const results = await Promise.allSettled(
    filepaths.map(generateFunctionMetadata)
  );
  const functionMetadataArray = [];
  results.forEach((result) => {
    if (result.status === "fulfilled") {
      if (result.value) {
        functionMetadataArray.push(result.value);
      }
    } else {
      throw result.reason;
    }
  });
  return Object.fromEntries(functionMetadataArray);
};
async function generateFunctionMetadata(filepath) {
  const relativePath = path.relative(process.cwd(), filepath);
  const hasMainExport = project.getSourceFile(filepath)?.getExportedDeclarations().has("main");
  if (hasMainExport) {
    return;
  }
  const defaultExportDeclaration = project.getSourceFile(filepath)?.getDefaultExportSymbol()?.getDeclarations()[0];
  if (Node.isExportAssignment(defaultExportDeclaration)) {
    const entrypoint = defaultExportDeclaration.getChildrenOfKind(SyntaxKind.Identifier)[0]?.getText();
    if (!entrypoint) {
      throw `${relativePath} contains an unsupported default export assignment. The default export must be a function, and it must be formatted as \`export default foo;\` for function \`foo\`.`;
    }
    return [relativePath, { entrypoint }];
  } else if (Node.isFunctionDeclaration(defaultExportDeclaration)) {
    const entrypoint = defaultExportDeclaration.getName();
    if (!entrypoint) {
      throw `${relativePath} contains an unsupported default function declaration. The default export function must be a named function, exported as \`export default function foo(){}\` for function \`foo\`.`;
    }
    return [relativePath, { entrypoint }];
  }
  throw `${relativePath} does not contain a properly formatted default export. The default export must be named and declared either in the function declaration or in an \`export default ...;\` expression.`;
}
const generateFunctionMetadataFile = async (projectStructure) => {
  const functionMetadataMap = await getFunctionMetadataMap(projectStructure);
  const { rootFolders, distConfigFiles } = projectStructure.config;
  fs.writeFileSync(
    path.join(rootFolders.functions, distConfigFiles.functionMetadata),
    JSON.stringify(functionMetadataMap, null, 2)
  );
};
const shouldGenerateFunctionMetadata = (projectStructure) => {
  return fs.existsSync(projectStructure.config.rootFolders.functions);
};
export {
  generateFunctionMetadataFile,
  shouldGenerateFunctionMetadata
};
