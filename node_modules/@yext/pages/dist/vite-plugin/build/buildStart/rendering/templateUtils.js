import { getRelativePrefixToRootFromPath } from "../../../../common/src/template/paths.js";
import { reactWrapper } from "./wrapper.js";
import {
  convertTemplateModuleToTemplateModuleInternal
} from "../../../../common/src/template/internal/types.js";
import { validateGetPathValue } from "../../../../common/src/template/internal/validateGetPathValue.js";
const pathToModule = /* @__PURE__ */ new Map();
const readTemplateModules = async (feature, manifest, projectStructure) => {
  const path = manifest.serverPaths[feature].replace(
    projectStructure.config.subfolders.assets,
    ".."
  );
  if (!path) {
    throw new Error(`Could not find path for feature ${feature}`);
  }
  let importedModule = pathToModule.get(path);
  if (!importedModule) {
    importedModule = await import(path);
    pathToModule.set(path, importedModule);
  }
  const templateModuleInternal = convertTemplateModuleToTemplateModuleInternal(
    path,
    importedModule,
    true
  );
  return templateModuleInternal;
};
const getPluginRenderTemplates = async (manifest, projectStructure) => {
  const serverRenderPath = manifest.renderPaths._server.replace(
    projectStructure.config.subfolders.assets,
    ".."
  );
  const serverRenderTemplateModule = await importRenderTemplate(serverRenderPath);
  return {
    server: serverRenderTemplateModule,
    client: manifest.renderPaths._client
  };
};
const pluginRenderTemplatesCache = /* @__PURE__ */ new Map();
const importRenderTemplate = async (path) => {
  let module = pluginRenderTemplatesCache.get(path);
  if (!module) {
    module = await import(path);
    pluginRenderTemplatesCache.set(path, module);
  }
  return module;
};
const generateResponses = async (templateModuleInternal, templateProps, pluginRenderTemplates, manifest, projectStructure) => {
  if (templateModuleInternal.transformProps) {
    templateProps = await templateModuleInternal.transformProps(templateProps);
  }
  const path = templateModuleInternal.getPath(templateProps);
  validateGetPathValue(path, templateModuleInternal.templateName);
  const templateRenderProps = {
    ...templateProps,
    path,
    relativePrefixToRoot: getRelativePrefixToRootFromPath(path)
  };
  const content = await renderHtml(
    templateModuleInternal,
    templateRenderProps,
    pluginRenderTemplates,
    manifest,
    projectStructure
  );
  return {
    content,
    path,
    redirects: templateModuleInternal.getRedirects?.(templateRenderProps) ?? []
  };
};
const renderHtml = async (templateModuleInternal, props, pluginRenderTemplates, manifest, projectStructure) => {
  const { default: component, render, getHeadConfig } = templateModuleInternal;
  if (!component && !render) {
    throw new Error(
      `Cannot render html from template '${templateModuleInternal.config.name}'. Template is missing render function or default export.`
    );
  }
  if (render) {
    if (getHeadConfig) {
      console.warn(
        `getHeadConfig for template ${templateModuleInternal.config.name} will not be called since a custom render function is defined.`
      );
    }
    return render(props);
  }
  return await reactWrapper(
    props,
    templateModuleInternal,
    templateModuleInternal.config.hydrate,
    pluginRenderTemplates,
    manifest,
    projectStructure
  );
};
export {
  generateResponses,
  getPluginRenderTemplates,
  readTemplateModules
};
